const router = require('express').Router();

//  utilize mongoose validator to send a message to the user, which is in the Model
const mongoose = require('mongoose'); 

// the setup code skipped
const bcryptjs = require('bcryptjs');

// Require the Model to save the users in MongoDB
//The user model is the blueprint that will be used when new users are created
const User = require('../models/User.model');

// require (import) middleware functions
const { isLoggedIn, isLoggedOut } = require("../middleware/route-guard.js");

// GET route ==> to display the signup form to users
// isLoggedOut--> the user doesn't have a current session, and needs to Logged In first, take him/her to this /signup
//                     .: ADDED :.
router.get('/signup', isLoggedOut, async (req, res) => {
  // if there is an err in the url, it will passed to the view 'auth/signup' ans be shown
  const { err } = req.query;
  res.render('auth/signup', { err });
});

// Regex to email and password
const emailRegex = /^\S+@\S+\.\S+$/;
const passwordRegex = /(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{6,}/;

// Check if email /password doestn't match the regex -> use .test()
function hasPasswordWrongFormat(password) {
  return !passwordRegex.test(password);
}

// Check if email /password doestn't match the regex -> use .test()
function hasEmailWrongFormat(email) {
  return !emailRegex.test(email);
}

// Mongoose validator with the model
// Error [ValidationError] , and it comes from mongoose
function isValidationError(error) {
  // check if the error object is an instance of mongoose ValidationError contructro function
  return error instanceof mongoose.Error.ValidationError;
}
// MongoError: E11000, and it is a native MongoDB error.
// When there are duplicates keys
function isMongoError(error) {
  // when mongo throws an error it gives it the code 11000
  return error.code === 11000;
}

// POST route ==> to process form data
// isLoggedOut--> the user doesn't have a current session, and needs to Logged In first, take him/her to this /signup
//                      .: ADDED :.
router.post('/signup', isLoggedOut, async (req, res) => {
  try {
    const { username, email, password } = req.body;
    // console.log("The form data: ", req.body);
    
    const hassMissingCredentials = !email || !password || !username;
    if (hassMissingCredentials ) {
      return res.redirect("/signup?err=Missing credentials, enter at least an email and password");
    }
    // Iteration 2 
    // make sure passwords are strong:
    if (hasPasswordWrongFormat(password)) {
      return res.redirect("/signup?err=Password needs to have at least 6 char and contain at least one number, one lowercase and one uppercase letter.");
    }

    if (hasEmailWrongFormat(email)) {
      return res.redirect("/signup?err=Email needs to be like: user@.email.com");
    }
   
    //salt rounds is a number from 0 to 20 that defines the complexity of the salt
    const saltRounds = 10;
    // salt is a random string generated by bcrypt to add complexity in the hast
    const salt = await bcryptjs.genSalt(saltRounds);
    // hash the password received from the req.body
    // create the has out of the password and the salt
    const hashedPassword = await bcryptjs.hash(password, salt);
    // save all the attributes, except the passwordHash
    const {passwordHash: unusedvar, ...newUser} = await User.create({
      username,
      email,
      passwordHash: hashedPassword,
    }).lean(); // .lean() --> will give us JSON object, not the object from mongoose
    console.log('Newcreated user is: ', newUser);
    req.session.currentUser = newUser;
    res.redirect('/userProfile');
    
  } catch (err) {
    if (isValidationError(err)) {
      return res.redirect("/signup?err=validation error");
    }
    if (isMongoError(err)) {
      return res.redirect("/signup?err=This email in use");
    }
    console.error(err);
    return res.redirect("/signup?err=something went wrong");
  }
  // } catch(error) {
  //   // Mongoose validator with the model
  //   // Error [ValidationError] , and it comes from mongoose
  //   if (error instanceof mongoose.Error.ValidationError) {
  //     res.status(500).render('auth/signup', { err: error.message });
  //   } else if (error.code === 11000) {
  //     // MongoError: E11000, and it is a native MongoDB error.
  //     // When there are duplicates keys
  //     res.status(500).render('auth/signup', {
  //        err: 'Username and email need to be unique. Either username or email is already used.'
  //     });
  //   } else {
  //     next(error);
  //   }
  // }
});

/////////// LOGIN ////////////
// GET route ==> to display the login form to users
router.get('/login', isLoggedOut, async (req, res) => {
    // if there is an err in the url, it will passed to the view 'auth/login' ans be shown
    const { err } = req.query;
    res.render('auth/login', { err });
});

// POST route ==> to get the login information from the form
router.post('/login', async (req, res) => {
 try {
  const { email, password } = req.body;
  // console.log("The form data: ", req.body);

  const hassMissingCredentials = !email || !password;
  if (hassMissingCredentials ) {
    return res.redirect("/login?err=Missing credentials");
  }
  // Check if there is wrong password
  if (hasPasswordWrongFormat(password)) {
    return res.redirect("/signup?err=Password needs to have at least 6 char and contain at least one number, one lowercase and one uppercase letter.");
  }
 // Check if there is wrong email
  if (hasEmailWrongFormat(email)) {
    return res.redirect("/signup?err=Email needs to be like: user@.email.com");
  }

  // email is unique
  const user = await User.findOne( { email }).lean();
  console.log(email)
  if (!user) {
    return res.redirect("/login?err=The user wasn't found");
  }
  const hasCorrectPassword = await bcryptjs.compareSync(password, user.passwordHash);
  if (hasCorrectPassword) {
    //******* SAVE THE USER IN THE SESSION ********//
    const { passwordHash, ...currentUser } = user;
    // create a currentUser without passwordHash
    req.session.currentUser = currentUser;
    console.log('user', user); // user has: id, username, email and passwordHash
    console.log('currentUser', currentUser); // current user has: id, username, email
    return res.redirect("/userProfile")
  }
  return res.redirect("/login?err=wrong password");
  } catch (err) {
    if (isValidationError(err)) {
      return res.redirect("/login?err=validation error");
    }
    if (isMongoError(err)) {
      return res.redirect("/login?err=mongo error");
    }
    console.error(err);
    return res.redirect("/login?err=something went wrong");
  }
});

// GET - /userProfile --> when the user has already logged In
// isLoggedIn--> the user has a current session, or has already logged In, so next(), take the user to the route requested--> GET /userProfile
//                         .: ADDED :.
router.get("/userProfile", isLoggedIn,  async ( req, res) => {
  res.render("users/user-profile", { userInSession: req.session.currentUser });
});

// POST - logout --> the server is going to destroy or remove the session for the user (the cookie is removed)
// isLoggedIn--> the user has a current session, or has already logged In, so next(), take the user to the route requested--> POST /logout
//                         .: ADDED :.
router.post("/logout",  isLoggedIn, async (req, res, next) => {
  try {
    // destroy the session from the server
    req.session.destroy();
    res.redirect("/");
    // req.session.destroy(err => {
    //   if (err) next(err);
    //   res.redirect("/");
    // });
  } catch(error) {
    console.error('Something wrong with the logout', error)
    next(error)
  }
});

// GET - only users authenticated (logged in and exist in the session) can visit this /main
router.get("/main", isLoggedIn, async (req, res, next) => {
  try {
    res.render('auth/main');
  } catch(error) {
    console.error('Something wrong!, please try again!', error);
    next(error);
  }
});

// GET - only users authenticated (logged in and exist in the session) can visit this /main
router.get("/private", isLoggedIn, async (req, res, next) => {
  try {
    res.render('auth/private');
  } catch(error) {
    console.error('Something wrong!, please try again!', error);
    next(error);
  }
});


module.exports = router;


